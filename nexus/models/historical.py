"""
Nexus Model Generator
=========================

Module: ``nexus.models.historical``
Author: Architected for Nexus v2.0
Description: Non-parametric Historical Simulation model.
"""

import numpy as np
from typing import Union, Dict, Any, Optional
import numpy.typing as npt

from nexus.core.base import AbstractRiskModel
from nexus.metrics import tail, moments, drawdown, dispersion, downside, entropic

class HistoricalRiskModel(AbstractRiskModel):
    r"""
    Non-Parametric Historical Simulation Risk Model.

    Unlike parametric models (Delta-Normal), Historical Simulation makes no
    assumptions about the underlying probability distribution of asset returns.
    It simply projects historical realizations into the future. It is widely
    considered the most fundamentally sound risk model, provided the historical
    "lookback" window encompasses a sufficiently representative spectrum of
    market regimes (including crises).

    Mathematical Formulation
    ------------------------
    .. math::
       \hat{F}(x) = \frac{1}{T} \sum_{t=1}^{T} \mathbb{I}(X_t \leq x)

    Where:
    - :math:`\hat{F}(x)` is the empirical cumulative distribution function (CDF).
    - :math:`\mathbb{I}` is the indicator function.

    Attributes
    ----------
    empirical_returns : ndarray of shape (T, N)
        The calibrated historical lookback window.
    """

    def __init__(self):
        super().__init__()
        self.empirical_returns: Optional[npt.NDArray[np.float64]] = None

    def calibrate(self, historical_returns: Union[npt.NDArray[np.float64], Any]) -> 'HistoricalRiskModel':
        r"""
        Calibrates the model by ingesting the empirical return distribution.

        Parameters
        ----------
        historical_returns : ndarray of shape (T, N)
            Matrix of historical asset or exact portfolio returns.

        Returns
        -------
        self : HistoricalRiskModel
            Returns initialized self object for chaining.
        """
        arr = self._validate_data(historical_returns)
        self.empirical_returns = arr
        return self

    def simulate(
        self, 
        n_paths: int = 10000, 
        horizon: int = 21, 
        bootstrap: bool = True
    ) -> npt.NDArray[np.float64]:
        r"""
        Generates forward-looking scenarios via Historical Bootstrapping.

        If bootstrapping is enabled, paths are generated by drawing randomly
        with replacement from the calibrated empirical distribution.

        Mathematical Formulation (Bootstrapping i.i.d.)
        -----------------------------------------------
        .. math::
           X^s_t \sim \text{DiscreteUniform}(X_1, X_2, \dots, X_T)

        Parameters
        ----------
        n_paths : int, default 10000
            Number of simulated future paths.
        horizon : int, default 21
            Number of forward steps per path (e.g., 21 days for a trading month).
        bootstrap : bool, default True
            If True, sample with replacement.

        Returns
        -------
        simulated_returns : ndarray of shape (n_paths, horizon, N)
            The generated stochastic return paths.
        """
        self._check_is_calibrated('empirical_returns')
        T, num_assets = self.empirical_returns.shape
        # Vectorized random sampling with replacement
        indices = np.random.choice(T, size=(n_paths, horizon), replace=bootstrap)
        return self.empirical_returns[indices]

    def quantify(
        self, 
        metric: str = 'VaR', 
        alpha: float = 0.05, 
        **kwargs
    ) -> Union[float, npt.NDArray[np.float64]]:
        r"""
        Quantifies the specified risk metric over the exact calibrated history.

        Parameters
        ----------
        metric : str, default 'VaR'
            The mathematical risk metric to extract.
            Supported metrics: 'VaR', 'CVaR', 'MDD', 'Vol', 'Skew', 'EVaR', 'CDaR', etc.
        alpha : float, default 0.05
            The significance level (1 - confidence) mapping to the distribution tail.

        Returns
        -------
        risk_value : float or ndarray
            The quantified risk exposure.
        """
        self._check_is_calibrated('empirical_returns')
        ret = self.empirical_returns

        metric = metric.lower()
        if metric == 'var':
            return tail.compute_var(ret, alpha=alpha)
        elif metric == 'cvar':
            return tail.compute_cvar(ret, alpha=alpha)
        elif metric == 'max_loss':
            return tail.compute_max_loss(ret)
        elif metric == 'evar':
            return entropic.compute_evar(ret, alpha=alpha)
        elif metric == 'cdar':
            return drawdown.compute_cdar(ret, alpha=alpha)
        elif metric == 'mdd':
            return drawdown.compute_max_drawdown(ret)
        elif metric == 'vol':
            return moments.compute_volatility(ret)
        elif metric == 'mad':
            return dispersion.compute_mad(ret)
        else:
            raise ValueError(f"Unknown metric '{metric}' for HistoricalRiskModel.")
